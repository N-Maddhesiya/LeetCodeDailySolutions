class UnionFind {
public:
    UnionFind(int n): parent(n), rankv(n) {
        for(int i = 0; i < n; i++) parent[i] = i;
    }
    int find(int x) {
        return parent[x] == x ? x : parent[x] = find(parent[x]);
    }
    void unite(int a, int b) {
        int pa = find(a), pb = find(b);
        if(pa == pb) return;
        if(rankv[pa] < rankv[pb]) parent[pa] = pb;
        else if(rankv[pa] > rankv[pb]) parent[pb] = pa;
        else { parent[pb] = pa; rankv[pa]++; }
    }
    bool connected(int a, int b) {
        return find(a) == find(b);
    }
    void reset(int x) {
        parent[x] = x;
    }
private:
    vector<int> parent, rankv;
};

class Solution {
public:
    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {
        sort(meetings.begin(), meetings.end(), [](auto &a, auto &b) {
            return a[2] < b[2];
        });
        UnionFind uf(n);
        uf.unite(0, firstPerson);
        int i = 0, m = meetings.size();
        while(i < m) {
            int t = meetings[i][2];
            vector<pair<int,int>> batch;
            while(i < m && meetings[i][2] == t) {
                batch.emplace_back(meetings[i][0], meetings[i][1]);
                i++;
            }
            unordered_set<int> involved;
            for(auto &p : batch) {
                uf.unite(p.first, p.second);
                involved.insert(p.first);
                involved.insert(p.second);
            }
            for(int p : involved) {
                if(!uf.connected(p, 0)) uf.reset(p);
            }
        }
        vector<int> ans;
        for(int p = 0; p < n; p++) {
            if(uf.connected(p, 0)) ans.push_back(p);
        }
        return ans;
    }
};
